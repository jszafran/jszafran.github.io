<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Carthesian Product | jszafran.dev</title>
<meta name="keywords" content="">
<meta name="description" content="I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:
[(&#34;calendar&#34;, &#34;year&#34;), (&#34;calendar&#34;, &#34;month&#34;), (&#34;calendar&#34;, &#34;day&#34;)] Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.
calendar year month day 0 2019 2 1 1 2019 3 10 In order to create such multiindex, I needed to generate carthesian product of calendar and year, month, day.">
<meta name="author" content="">
<link rel="canonical" href="http://foo.com/posts/carthesian-product4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://foo.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://foo.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://foo.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://foo.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://foo.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Carthesian Product" />
<meta property="og:description" content="I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:
[(&#34;calendar&#34;, &#34;year&#34;), (&#34;calendar&#34;, &#34;month&#34;), (&#34;calendar&#34;, &#34;day&#34;)] Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.
calendar year month day 0 2019 2 1 1 2019 3 10 In order to create such multiindex, I needed to generate carthesian product of calendar and year, month, day." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://foo.com/posts/carthesian-product4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-15T10:39:58&#43;02:00" />
<meta property="article:modified_time" content="2022-08-15T10:39:58&#43;02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Carthesian Product"/>
<meta name="twitter:description" content="I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:
[(&#34;calendar&#34;, &#34;year&#34;), (&#34;calendar&#34;, &#34;month&#34;), (&#34;calendar&#34;, &#34;day&#34;)] Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.
calendar year month day 0 2019 2 1 1 2019 3 10 In order to create such multiindex, I needed to generate carthesian product of calendar and year, month, day."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://foo.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Carthesian Product",
      "item": "http://foo.com/posts/carthesian-product4/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Carthesian Product",
  "name": "Carthesian Product",
  "description": "I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:\n[(\u0026#34;calendar\u0026#34;, \u0026#34;year\u0026#34;), (\u0026#34;calendar\u0026#34;, \u0026#34;month\u0026#34;), (\u0026#34;calendar\u0026#34;, \u0026#34;day\u0026#34;)] Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.\ncalendar year month day 0 2019 2 1 1 2019 3 10 In order to create such multiindex, I needed to generate carthesian product of calendar and year, month, day.",
  "keywords": [
    
  ],
  "articleBody": "I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:\n[(\"calendar\", \"year\"), (\"calendar\", \"month\"), (\"calendar\", \"day\")] Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.\ncalendar year month day 0 2019 2 1 1 2019 3 10 In order to create such multiindex, I needed to generate carthesian product of calendar and year, month, day.\nPandas MultiIndex object provides constructor methods for doing that, for example pd.MultiIndex.from_product:\nimport pandas as pd multi_index = pd.MultiIndex.from_product([(\"calendar\",), (\"year\", \"month\", \"day\")]) But I was also wondering if the same can be achieved with just the Python’s standard library (and without using nested for loops).\nzip \u0026 itertools.zip_longest My initial hunch was to check if there’s any parameter to built-in zip function to make it behave to fit my use-case. Zip stops at the shortest iterable so in my case\nlist(zip((\"calendar\",), (\"year\", \"month\", \"day\"))) would return:\n[('calendar', 'year')] Google advised to take a look itertools.zip_longest. Citing official documentation’s definition:\nMake an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted\nLet’s compare the results using default \u0026 custom fillvalue.\nWithout providing fillvalue argument:\nfrom itertools import zip_longest zip_longest((\"calendar\",), (\"year\", \"month\", \"day\")) gives\n[('calendar', 'year'), (None, 'month'), (None, 'day')] With fillvalue = \"calendar\":\nfrom itertools import zip_longest list(zip_longest((\"calendar\",), (\"year\", \"month\", \"day\"), fillvalue=\"calendar\")) gives\n[('calendar', 'year'), ('calendar', 'month'), ('calendar', 'day')] As you can see, zip_longest with fillvalue gives us desired result. But is there a better way?\nitertools.product There is! And it’s called itertools.product.\nitertools.product -\u003e Cartesian product of input iterables.\nfrom itertools import product list(product((\"calendar\",), (\"year\", \"month\", \"day\"))) gives\n[('calendar', 'year'), ('calendar', 'month'), ('calendar', 'day')] Exactly what we needed!\nSidenote: itertools.product does not discard duplicates. If you care about not having them, use set to remove them.\nThat’s it for this post. Hope you learnt something new today. Best Regards, Kuba\n",
  "wordCount" : "345",
  "inLanguage": "en",
  "datePublished": "2022-08-15T10:39:58+02:00",
  "dateModified": "2022-08-15T10:39:58+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://foo.com/posts/carthesian-product4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "jszafran.dev",
    "logo": {
      "@type": "ImageObject",
      "url": "http://foo.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://foo.com/" accesskey="h" title="jszafran.dev (Alt + H)">jszafran.dev</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://foo.com/about/" title="about hugo">
                    <span><i class='fa fa-heart'></i>about hugo</span>
                </a>
            </li>
            <li>
                <a href="http://foo.com/getting-started/" title="Menu 2">
                    <span><i class='fa fa-road'></i>Menu 2</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Carthesian Product
    </h1>
    <div class="post-meta"><span title='2022-08-15 10:39:58 +0200 CEST'>August 15, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>I recently worked on some side project that was using pandas dataframe with 2-level multiindexed columns. They could be represented as list of tuples, for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[(<span style="color:#e6db74">&#34;calendar&#34;</span>, <span style="color:#e6db74">&#34;year&#34;</span>), (<span style="color:#e6db74">&#34;calendar&#34;</span>, <span style="color:#e6db74">&#34;month&#34;</span>), (<span style="color:#e6db74">&#34;calendar&#34;</span>, <span style="color:#e6db74">&#34;day&#34;</span>)]</span></span></code></pre></div>
<p>Dataframe with such index would look like this - calendar being the upper level and year, month, day on the lower level.</p>
<pre tabindex="0"><code>      calendar          
      year month day
0     2019     2   1
1     2019     3  10
</code></pre><p>In order to create such multiindex, I needed to generate carthesian product of <code>calendar</code> and <code>year, month, day</code>.</p>
<p>Pandas MultiIndex object provides constructor methods for doing that, for example <code>pd.MultiIndex.from_product</code>:</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">import pandas as pd

multi_index = pd.MultiIndex.from_product([(&#34;calendar&#34;,), (&#34;year&#34;, &#34;month&#34;, &#34;day&#34;)])
</code></pre><p>But I was also wondering if the same can be achieved with just the Python&rsquo;s standard library (and without using nested for loops).</p>
<h2 id="zip--itertoolszip_longest">zip &amp; itertools.zip_longest<a hidden class="anchor" aria-hidden="true" href="#zip--itertoolszip_longest">#</a></h2>
<p>My initial hunch was to check if there&rsquo;s any parameter to built-in <code>zip</code> function to make it behave to fit my use-case. <code>Zip</code> stops at the shortest iterable so in my case</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">list(zip((&#34;calendar&#34;,), (&#34;year&#34;, &#34;month&#34;, &#34;day&#34;)))
</code></pre><p>would return:</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">[(&#39;calendar&#39;, &#39;year&#39;)]
</code></pre><p>Google advised to take a look <code>itertools.zip_longest</code>. Citing official <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest">documentation&rsquo;s definition</a>:</p>
<blockquote>
<p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted</p>
</blockquote>
<p>Let&rsquo;s compare the results using default &amp; custom fillvalue.</p>
<p>Without providing <code>fillvalue</code> argument:</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">from itertools import zip_longest

zip_longest((&#34;calendar&#34;,), (&#34;year&#34;, &#34;month&#34;, &#34;day&#34;))
</code></pre><p>gives</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">[(&#39;calendar&#39;, &#39;year&#39;), (None, &#39;month&#39;), (None, &#39;day&#39;)]
</code></pre><p>With <code>fillvalue = &quot;calendar&quot;</code>:</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">from itertools import zip_longest

list(zip_longest((&#34;calendar&#34;,), (&#34;year&#34;, &#34;month&#34;, &#34;day&#34;), fillvalue=&#34;calendar&#34;))
</code></pre><p>gives</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">[(&#39;calendar&#39;, &#39;year&#39;), (&#39;calendar&#39;, &#39;month&#39;), (&#39;calendar&#39;, &#39;day&#39;)]
</code></pre><p>As you can see, <code>zip_longest</code> with <code>fillvalue</code> gives us desired result. But is there a better way?</p>
<h2 id="itertoolsproduct">itertools.product<a hidden class="anchor" aria-hidden="true" href="#itertoolsproduct">#</a></h2>
<p>There is! And it&rsquo;s called <code>itertools.product</code>.</p>
<blockquote>
<p>itertools.product -&gt; Cartesian product of input iterables.</p>
</blockquote>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">from itertools import product

list(product((&#34;calendar&#34;,), (&#34;year&#34;, &#34;month&#34;, &#34;day&#34;)))
</code></pre><p>gives</p>
<pre tabindex="0"><code class="language-{.python}" data-lang="{.python}">[(&#39;calendar&#39;, &#39;year&#39;), (&#39;calendar&#39;, &#39;month&#39;), (&#39;calendar&#39;, &#39;day&#39;)]
</code></pre><p>Exactly what we needed!</p>
<p>Sidenote: <code>itertools.product</code> does not discard duplicates. If you care about not having them, use <code>set</code> to remove them.</p>
<p>That&rsquo;s it for this post. Hope you learnt something new today.
<!-- raw HTML omitted --><!-- raw HTML omitted -->
Best Regards,<!-- raw HTML omitted -->
Kuba</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="http://foo.com/">jszafran.dev</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
